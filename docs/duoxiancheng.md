## 1.并发编程的三要素：  

​	1.原子性：一个或者多个操作，要么都执行，要么都不执行 

​	 2.可见性：多个线程操作一个共享变量时，其中一个线程对变量进行修改后，其他线程可以立即看到修改的结果  

​	 3.有序性：程序的执行顺序按照代码的先后顺序来执行

## 2.实现可见性的方法：  

​	 sychronized或者Lock：保证同一时刻只有一个线程获取锁执行代码

## 3.sychronized： 

​	 用来控制线程同步的，在多线程环境下，控制sychronized代码段不被多个线程同时执行，既可以加在代码上也可以加在方法上

## 4.volatile： 

​	 volatile关键字保证可见性，当一个共享变量被volatile修饰时，它会保证修改的值立即被更新到主存

## 5.创建线程有哪几种不同的方式？  

​	 1.继承Thread类 

​	 2.实现Runnable接口  

​	 3.通过线程池创建  

​	实现Runnable接口这种方法更受欢迎，因为不需要继承Thread类。在已经继承别的类的情况下，继承Thread类需要多继承，而Java不支持

## 6.线程的几种状态？ 

1.新建（new）：新创建了一个线程对象  

2.可运行（runnable）：线程对象创建后，其他线程调用了该对象的start()方法，该状态的线程位于可运行线程池中，等待被线程调度选中，获得cpu使用权  

3.运行（running）：可运行状态的线程获得了cpu时间片，执行程序  

4.阻塞（block）：线程因为某种原因放弃了cpu时间片，暂时停止运行。直到线程进入可运行状态，才有机会再次获得cpu时间片转到运行状态     

​	等待阻塞：运行的线程执行.wait方法，JVM将该线程放入等待队列     

​	同步阻塞：运行的线程在获取对象的同步锁时，该同步锁被其他线程占用，JVM将该线程放入锁池中    

​    其他阻塞  

5.死亡：线程run()、main()方法执行结束，或者因为异常退出了run()方法，则线程结束生命周期，不可再次复生

## 7.同步代码块和同步方法的区别？  

​	 同步方法默认使用this或者当前类class对象作为锁  同步代码块选择用什么东西来加锁，可以选择只同步会发生同步问题的部分代码而不是整个方法

## 8.死锁？   

​	 两个或两个以上线程都在等对方执行完毕才能继续往下执行的时候就发生了死锁，都陷入无限等待中

## 9.多线程产生死锁的四个必要条件？  

​	互斥条件：一个资源每次只能被一个进程使用  

​	保持和请求条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放  

​	不可剥夺性：进程已获得资源，在未使用完之前，不能被剥夺  

​	循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系

## 10.如何确保N个线程可以访问N个资源同时又不导致死锁？  

​	破坏以上任意一个条件即可  避免死锁的方法：指定获取锁的顺序，且强制线程按照指定顺序获得锁